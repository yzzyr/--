# **Assignment P 之笔试总结**
（笔试后对之前复习时的方法整理，笔试时用的是其他同学的优秀cheat sheet来源于yhf老师课件、gw老师课件、internet大神）

## **一**
**首先放一个数算电子教材：https://www.hello-algo.com/ 墙裂推荐**
来源于：https://github.com/krahets
这一本已经出版了纸质书，但我认为电子版更方便理解，包含了pythontutor的可视化运行。
主要内容分为15章，包括算法、复杂度、数据结构、数组与链表、栈与队列、哈希表、树、堆、图、搜索、排序、分治、回溯、动态规划、贪心等。
可以从程序本身帮助理解算法，加深对程序的理解，促进更好地运用。
其中的示例很丰富，对概念性的知识进行了辅助。

## **二**
老师们的课件各有特色。
闫老师的课件包含了概念（来源于多方，很多英文），各种结构的实现程序，各种定义，一部分基础题目，还有笔试题目（选择、判断）等。
其他老师的课件更偏向于笔试风格的概念，但通常一句带过，没有很多便于理解的介绍。还有部分模板题、经典题。

## **三**
**需要记忆的概念，重点为数据结构、排序、多种类的运用**
（其实平时作业认真完成，有不会的看懂题解之后做两到三遍，加上往年题训练，程序填空就没太大问题了，所以主要是概念很让人头疼）
### 算法
算法是对计算过程的描述，是为了解决某个问题而设计的有限长操作序列
算法具有以下特性：
有穷性：一个算法必须可以用有穷条指令描述，且必须在执行有穷次操作后终止。每次操作都必须在有穷时间内完成。算法终止后必须给出所处理问题的解或宣告问题无解。
确定性：一个算法,对于相同的输入，无论运行多少次，总是得到相同的输出。也可以说只要算法运行前的初始条件相同，那么算法运行的结果也相同。
可行性：算法中的指令（或描述语句）含义明确无歧义，且可以被机械化地自动执行。
输入/输出：输入指的是描述算法所处理的问题的数据，输出指的是描述该问题的答案的数据。算法可以不需要输入。但是没有输出的算法是没有意义的。

### 程序或算法的时间复杂度
一个程序或算法的时间效率，也称“时间复杂度”，有时简称“复杂度”
复杂度常用大的字母O和小写字母n来表示，比如O(n),O(n2)等。n代表问题的规模。O(X）就表示解决问题的时间和X成正比关系(粗略理解）
时间复杂度是用算法运行过程中，某种时间固定的操作需要被执行的次数和n的关系来度量的。在无序数列中查找某个数，复杂度是O(n)

### O(1) 复杂度的常见操作
1)根据下标访问列表、字符串、元组中的元素
2)在集合、字典中增删元素
3)调用列表的append函数在列表末尾添加元素，以及用pop()函数删除列表末尾元素
4)用in判断元素是否在集合中或某关键字是否在字典中
5)以关键字为下标访问字典中的元素的值
6)用len函数求列表、元组、集合、字典的元素个数

O(n) 复杂度的常见操作
1)用in 判断元素是否在字符串、元组、列表中
2)用insert在列表中插入元素
3)用remove或del删除列表中的元素
4)用字符串、元组或列表的find、rfind、index等函数做顺序查找
5)用字符串、元组或列表的count函数计算元素出现次数
6)用max,min函数求列表、元组的最大值，最小值
7)列表和元组加法

### 数据结构
数据结构(data structure)就是数据的组织和存储形式。描述一个数据结构，需要指出其逻辑结构、存储结构和可进行的操作。
将数据的单位称作“元素”或“结点”。数据结构描述的就是结点之间的关系。

### 数据的逻辑结构
从逻辑上描述结点之间的关系，和数据的存储方式无关。
集合结构：结点之间没有什么关系，只是属于同一集合。如set。
线性结构：除了最靠前的结点，每个结点有唯一前驱结点；除了最靠后的结点，每个结点有唯一后继结点。如list。
树结构：有且仅有一个结点称为”根结点”，其没有前驱(父结点)；有若干个结点称为 “叶结点”，没有后继(子结点)；其它结点有唯一前驱，有1个或多个后继。如家谱 
图结构：每个结点都可以有任意多个前驱和后继，两个结点还可以互为前驱后继。如铁路网，车站是结点。
 
### 数据的存储结构
数据在物理存储器上存储的方式，大部分情况下指的是数据在内存中存储的方式。
顺序结构：结点在内存中连续存放，所有结点占据一片连续的内存空间。如list。
链接结构：结点在内存中可不连续存放，每个结点中存有指针指向其前驱结点和/或后继结点。如链表，树。
索引结构：将结点的关键字信息（比如学生的学号）拿出来单独存储，并且为每个关键字x配一个指针指向关键字为x的结点，这样便于按照关键字查找到相应的结点。
散列结构：设置散列函数，散列函数以结点的关键字为参数，算出一个结点的存储位置。

### 线性表
线性表是一个元素构成的序列
该序列有唯一的头元素和尾元素，除了头元素外，每个元素都有唯一的前驱元素，除了尾元素外，每个元素都有唯一的后继元素
线性表中的元素属于相同的数据类型，即每个元素所占的空间必须相同。
分为顺序表和链表两种

### 顺序表
即Python的列表，以及其它语言中的数组
元素在内存中连续存放
每个元素都有唯一序号(下标），且根据序号访问（包括读取和修改）元素的时间复杂度是O(1)的  --- 随机访问
下标为i的元素前驱下标为i-1，后继下标为i+1

### 链表
元素在内存中并非连续存放，元素之间通过指针链接起来
每个结点除了元素，还有next指针，指向后继
不支持随机访问。访问第i个元素，复杂度为O(n)
已经找到插入或删除位置的情况下，插入和删除元素的复杂度O(1),且不需要复制或移动结点
有多种形式：    
 单链表
 循环单链表
 双向链表
 循环双向链表

### 二叉树的定义
二叉树是有限个元素的集合。
空集合是一个二叉树，称为空二叉树。
一个元素(称其为“根”或“根结点”)，加上一个被称为“左子树”的二叉树，和一个被称为“右子树”的二叉树，就能形成一个新的二叉树。要求根、左子树和右子树三者没有公共元素。

### 二叉树的性质
1) 第i层最个多2i个结点
2) 高为h的二叉树结点总数最多2h+1-1
3) 结点数为n的树，边的数目为n-1
4) n个结点的非空二叉树至少有⌈log2(n+1)⌉层结点，即高度至少为⌈log2(n+1)⌉- 1
5) 在任意一棵二叉树中，若叶子结点的个数为n0，度为2的结点个数为n2，则n0=n2+1。
6) 非空满二叉树叶结点数目等于分支结点数目加1。
7）非空二叉树中的空子树数目等于其结点数目加1。

### 完全二叉树的性质
1) 完全二叉树中的1度结点数目为0个或1个
2) 有n个结点的完全二叉树有⌊(n+1)/2⌋个叶结点。
3) 有n个叶结点的完全二叉树有2n或2n-1个结点(两种都可以构建)
4) 有n个结点的非空完全二叉树的高度为⌈log2(n+1)⌉-1。即：有n个结点的非空完全二叉树共有⌈log2(n+1)⌉层结点。

### 二叉排序树(二叉查找树)
是一棵二叉树
每个结点存储关键字(key)和值(value)两部分数据
对每个结点X，其左子树中的全部结点的key都小于X的key，且X的key小于其右子树中的全部结点的key
一个二叉搜索树中的任意一棵子树都是二叉搜索树

性质：一个二叉树是二叉搜索树，当且仅当其
中序遍历序列是递增序列
略作修改就可以处理树结点key可以重复的情况

### 堆的性质
堆顶元素是优先级最高的(优先级高可自定义）
堆中的任何一棵子树都是堆
往堆中添加一个元素，并维持堆性质，复杂度O(log(n))
删除堆顶元素，剩余元素依然维持堆性质，复杂度O(log(n))
在无序列表中原地建堆，复杂度O(n)

### 图的相关概念
顶点的度数：和顶点相连的边的数目。
顶点的出度：有向图中，以该顶点作为起点的边的数目
顶点的入度：有向图中，以该顶点作为终点的边的数目
顶点的出边：有向图中，以该顶点为起点的边
顶点的入边：有向图中，以该顶点为终点的边
路径：对于无向图，如果存在顶点序列Vi0,Vi1Vi2.....Vim,使得(Vi0,Vi1) ,(Vi1,vi2)...(Vim-1,Vim)都存在，则称（Vi0,Vi1...Vim)是从Vi0到Vim的一条路径。（对于有向图，把()换成<>)
路径的长度：路径上的边的数目
回路（环）：起点和终点相同的路径
简单路径：除了起点和终点可能相同外，其它顶点都不相同的路径
完全图：
完全无向图：任意两个顶点都有边相连
完全有向图：任意两个顶点都有两条方向相反的边
连通：如果存在从顶点u到顶点v的路径，则称u到v连通，或u可达v。无向图中，u可达v,必然v可达u。有向图中，u可达v，并不能说明v可达u。
连通无向图：图中任意两个顶点u和v互相可达。
强连通有向图：图中任意两个顶点u和v互相可达。
子图：从图中抽取部分或全部边和点构成的图
连通分量（极大连通子图）：无向图的一个子图，是连通的，且再添加任何一些原图中的顶点和边，新子图都不再连通。
强连通分量：有向图的一个子图，是强连通的，且再添加任何一些原图中的顶点和边，新子图都不再强连通。
带权图：边被赋予一个权值的图
网络：带权无向连通图

### 图的性质
图的边数等于顶点度数之和的一半
n个顶点的连通图至少有n-1条边
n个顶点的，无回路的连通图就是一棵树，有n-1条边

### 排序
https://github.com/yzzyr/--/blob/main/%E5%9B%BE%E7%89%871.png
